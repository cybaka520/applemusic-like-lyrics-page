import type { LyricWord } from "../interfaces.ts";

const CJKEXP = /^[\p{Unified_Ideograph}\u0800-\u9FFC]+$/u;

const hasSegmenter =
	typeof Intl !== "undefined" && typeof Intl.Segmenter !== "undefined";

/**
 * 将输入的单词重新分组，之间没有空格的单词将会组合成一个单词数组
 *
 * 例如输入：`["Life", " ", "is", " a", " su", "gar so", "sweet"]`
 *
 * 应该返回：`["Life", " ", "is", " a", [" su", "gar"], "so", "sweet"]`
 * @param words 输入的单词数组
 * @returns 重新分组后的单词数组
 */
export function chunkAndSplitLyricWords(
	words: LyricWord[],
): (LyricWord | LyricWord[])[] {
	const atoms: LyricWord[] = [];

	for (const w of words) {
		const content = w.word.trim();
		const isSpace = content.length === 0;

		if (isSpace) {
			atoms.push({ ...w });
			continue;
		}

		const parts = w.word.split(/(\s+)/).filter((p) => p.length > 0);

		let currentOffset = 0;
		const totalLength = w.word.replace(/\s/g, "").length || 1;

		for (const part of parts) {
			if (!part.trim()) {
				atoms.push({
					word: part,
					romanWord: "",
					startTime: 0,
					endTime: 0,
				});
				continue;
			}

			if (CJKEXP.test(part) && part.length > 1 && !w.romanWord) {
				const chars = part.split("");
				for (const char of chars) {
					const charDuration = (1 / totalLength) * (w.endTime - w.startTime);
					const startTime =
						w.startTime +
						(currentOffset / totalLength) * (w.endTime - w.startTime);
					atoms.push({
						word: char,
						romanWord: "",
						startTime: startTime,
						endTime: startTime + charDuration,
					});
					currentOffset += 1;
				}
			} else {
				const partRealLen = part.length;
				const duration =
					(partRealLen / totalLength) * (w.endTime - w.startTime);
				const startTime =
					w.startTime +
					(currentOffset / totalLength) * (w.endTime - w.startTime);

				atoms.push({
					word: part,
					romanWord: w.romanWord,
					startTime: startTime,
					endTime: startTime + duration,
				});
				currentOffset += partRealLen;
			}
		}
	}

	if (!hasSegmenter) {
		return atoms;
	}

	const fullText = atoms.map((a) => a.word).join("");
	const segmenter = new Intl.Segmenter(undefined, { granularity: "word" });
	const segments = Array.from(segmenter.segment(fullText));

	const result: (LyricWord | LyricWord[])[] = [];
	let atomIndex = 0;

	for (const segment of segments) {
		const segmentStr = segment.segment;
		const segmentGroup: LyricWord[] = [];

		let neededLength = segmentStr.length;

		while (neededLength > 0 && atomIndex < atoms.length) {
			const currentAtom = atoms[atomIndex];
			const atomLen = currentAtom.word.length;

			if (atomLen <= neededLength) {
				segmentGroup.push(currentAtom);
				neededLength -= atomLen;
				atomIndex++;
			} else {
				segmentGroup.push(currentAtom);
				neededLength = 0;
				atomIndex++;
			}
		}

		if (segmentGroup.length === 1) {
			result.push(segmentGroup[0]);
		} else if (segmentGroup.length > 1) {
			result.push(segmentGroup);
		}
	}

	while (atomIndex < atoms.length) {
		result.push(atoms[atomIndex++]);
	}

	return result;
}
